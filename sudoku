#! /usr/bin/python3

import sys
import exercises
import copy
from math import sqrt
from math import floor

# Naam         : M.J. van Keulen
# UvAnetID     : 6066364
# Studie       : BSc Informatica
#
# sudoku.py
# Takes a file of set format as argument representing a sudoku.
# Does some admin, creates tools
# Failed to implement a working backtracking algorithm without recursion
# Ik wist niet goed wat ik zou inleveren en wat niet, ik had het gevoel opweg te zijn.
# Vandaar dat ik het in lever as is, maar verdwaalde in mijn aanpak. Wilde schrappen
# maar kwam in tijd nood. Moet er harder aan trekken want ik denk dat ik er prima uit
# had kunnen komen met meer beter voorbereide vragen tijdens de werkgroepen. Nogmaals excuus voor het nakijken.

sudoku = exercises.readFile(sys.argv[-1])

#Print the sudoku we are working with
exercises.outputElementPerLine(sudoku)

sudokuSize = len(sudoku[0])
correctAnswers = list(range(1, sudokuSize + 1))

# The original values
rowArray = sudoku
blockArray = exercises.makeBlocks(sudoku)
columnArray = exercises.makeColumns(sudoku)

# Arrays to work in
copyRowArray = copy.copy(rowArray)
copyBlockArray = copy.copy(blockArray)
copyColumnArray = copy.copy(columnArray)

#The blanco fields(options), and their respective index(row, column)
optionsWithIndex = exercises.makeOptionsList(sudoku)
optionsWithIndexGuessed = []
options = [0]* len(optionsWithIndex)

def possibleAnswers(row, column):
    """Given a row and column index, representing the position of a possible sudoku answer,
    returns the possibleAnswers for that specific set of row, column and block"""
    possibleAnswers = []
    correspondingRow = copyRowArray[row]
    correspondingColumn = copyColumnArray[column]
    correspondingBlock = copyBlockArray[exercises.calculateBlockIndex(len(sudoku[0]), row, column)]

    #Union of the guaranteed values of the blocks/rows and columns
    total = list(set(correspondingRow) | set(correspondingBlock) | set(correspondingColumn))

    for answer in correctAnswers:
        if answer not in total:
            possibleAnswers.append(answer)

    return(possibleAnswers)

def allPossibleAnswers(options):
    """"Takes a list of 0s representing blanco fields with their corresponding rows and
    columns returns all the possible answers"""
    allPossibleAnswers = []

    for option in options:
        # [row, column, [possible answers]]
        allPossibleAnswers.append([option[1], option[2], possibleAnswers(option[1], option[2])])

    return(allPossibleAnswers)

def update(guess, row, column):
    """Updates the lists that are not worked in, should not be called during the traversal of the tree"""
    global rowArray
    global columnArray
    global blockArray
    global optionsWithIndex
    global basePossibleAnswers

    rowArray[row][column] = guess
    columnArray[column][row] = guess
    blockArray = exercises.makeBlocks(rowArray)

    #Update the blank fields based on the current state of the blocks/rows/columns
    optionsWithIndex = exercises.makeOptionsList(rowArray)

    #Generate a new list of all the answers based on the current options
    basePossibleAnswers = allPossibleAnswers(optionsWithIndex)

def updateCopies(guess, row, column):
    """Updates all the lists that are worked in"""
    global copyRowArray
    global copyColumnArray
    global copyBlockArray
    global copyPossibleAnswers
    global optionsWithIndex

    copyRowArray[row][column] = guess
    copyColumnArray[column][row] = guess
    copyBlockArray = exercises.makeBlocks(copyRowArray)

    copyOptionsWithIndex = exercises.makeOptionsList(sudoku)

    #Update the list of all the answers based on the current options
    copyPossibleAnswers = allPossibleAnswers(optionsWithIndex)

def restoreCopies():
    """Sets the working lists back to base values"""
    global copyRowArray
    global copyBlockArray
    global copyColumnArray
    global copyPossibleAnswers

    copyRowArray = copy.copy(rowArray)
    copyBlockArray = copy.copy(blockArray)
    copyColumnArray = copy.copy(columnArray)
    copyPossibleAnswers = copy.copy(basePossibleAnswers)

basePossibleAnswers = allPossibleAnswers(optionsWithIndex)

def fillInSingleAnswers(possibleAnswers):
    """If a blanco field in the sudoku only has one possible answer, update"""
    for answers in basePossibleAnswers:
        if (len(answers[2]) == 1):
            update(answers[2][0], answers[0], answers[1])

    #These values are guaranteed answers update originals and copies
    restoreCopies()

def legalGuess(possibleAnswer):
    """Updates copies for the guess, and checks if it is a possible guess"""
    row = possibleAnswer[0]
    column = possibleAnswer[1]
    guess = possibleAnswer[2][0]

    updateCopies(guess, row, column)

    for answers in copyPossibleAnswers:
        if (len(answers[2]) == 0):
            #TODO restore copies one step? maybe not here hm
            return False

    return True

copyOptionsWithIndex = copy.copy(optionsWithIndex)
copyPossibleAnswers = copy.copy(basePossibleAnswers)

fillInSingleAnswers(basePossibleAnswers)

print("Rows:   ", blockArray)
print("Blocks: ", blockArray)
print("Columns:", columnArray)
print("Options:", optionsWithIndex)

print("Possible answers, [row, column, [answers]]:", copyPossibleAnswers)

timeToGuess = copy.copy(basePossibleAnswers)

# for guesses in timeToGuess:
#     #If laatste guess..
#     row = guesses[0]
#     column = guesses[1]
#     for guess in guesses[2]:
#         update(guess, row, column)
#         possibleAnswers(row, column)
#         for answer in copyPossibleAnswers:
#             if (len(answer[2] < 0):
#                 #TODO Add check for last guess
#                 #No possible answers left, but have not reached the last guess
#                 reset()
#                 break
#             #Else move on to the next

# Take an answer out of the list, assume it true update row/block/column copies. Rerun possibleAnswers and
# allPossibleAnswers, if allPossibleAnswers has a field without answers take the next element and assume it true
